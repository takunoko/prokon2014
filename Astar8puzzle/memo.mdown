Wikipediaより抜粋

A\* のアルゴリズムの実装を以下に示す。

## 定義 ##
* `h*(n)` : 各頂点nからゴールまでの距離推定値(推定値は同じかそれより小さくなければならない) 最初の段階で適当な推定値を与える
* `h(n)` : nからゴールノードまでの最小コスト
* `g(n)` : スタートからnまでの最小コスト
* `f(n)` : スタートからnを通りゴールまで行った時のコスト  
    * `f=g+h`  
    * これはg,hが知らないと難しい
    * 推定値に置き換えると以下になる
    * `f*(n)=g*(n)+h*(n)`
* `g*(n)`: 探索の過程で推定値を求めていくことが出来る

h\*に適当な推定値を与えてg\*(n)は探索しながら適宜更新することで経路を求める

## 方法 ##

1. ゴールノード（G ）とスタートノード（S ）を作成する。また計算中のノードを格納しておくためのリスト（Openリスト）と、計算済みのノードを格納しておくリスト（Closeリスト）を用意する。
2. スタートノードをOpenリストに追加する、このとき g\*(S) = 0 であり f\*(S) = h\*(S) となる。また Closeリストは空にする。
3. Openリストが空なら探索は失敗とする（スタートからゴールにたどり着くような経路が存在しなかったことになる）。
4. Openリストに格納されているノードの内、最小の f\*(n) を持つノード n を取り出す。
5. n = G であるなら探索を終了する。それ以外の場合は n を Close リストに移す。
6. n に隣接している全てのノード（ここでは隣接ノードを m とおく）に対して以下の操作を行う
    1. f '(m) = g\*(n) + h\*(m) + COST(n,m) を計算する、ここで COST(n,m) はノード n から m へ移動するときのコストである。また g\*(n) は g\*(n) = f\*(n) - h\*(n) で求めることができる。
    2. m の状態に応じて以下の操作を行う
    3. m が Openリストにも Closeリストにも含まれていない場合 f\*(m) = f '(m) とし m を Openリストに追加する。このとき m の親を n として記録する。
    4. m が Openリストにある場合、f '(m) < f\*(m) であるなら f\*(m) = f '(m) に置き換える。このとき記録してある m の親を n に置き換える。
    5. m が Closeリストにある場合、f '(m) < f\*(m) であるなら f\*(m) = f '(m) として m を Openリストに移動する。また記録してある m の親を n に置き換える。
7. 3 以降を繰り返す。
8. 探索終了後 G から親を順次たどっていくと S から G までの最短経路が得られる。
